package loader

import (
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"golang.org/x/tools/go/packages"
)

func assert(b bool, msg string) {
	if !b {
		panic(msg)
	}
}

func panicIf(err error) {
	if err != nil {
		panic(err)
	}
}

func errLog(a ...any) {
	_, _ = fmt.Fprintln(os.Stderr, a...)
}

func mustMkDir(dir string) string {
	dir, err := filepath.Abs(dir)
	panicIf(err)
	err = os.MkdirAll(dir, os.ModePerm)
	panicIf(err)
	return dir
}

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Clear Pos ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

func ClearPos(n ast.Node) {
	posType := reflect.TypeOf(token.NoPos)
	ast.Inspect(n, func(n ast.Node) bool {
		if n != nil {
			v := reflect.ValueOf(n).Elem()
			fields := v.Type().NumField()
			for i := 0; i < fields; i++ {
				f := v.Field(i)
				if f.Type() == posType {
					if f.Interface() != token.NoPos {
						f.Set(reflect.ValueOf(token.Pos(1)))
					}
				}
			}
		}
		return true
	})
}

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Def & Uses ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

type (
	Def = *ast.Ident
	Use = *ast.Ident
)

func DefUses(l *Loader) map[Def][]Use {
	obj2uses := map[types.Object][]*ast.Ident{}
	def2Objs := map[*ast.Ident][]types.Object{} // test and non-test

	l.VisitAllPackages(nil, func(pkg *packages.Package) {
		info := pkg.TypesInfo
		for id, obj := range info.Uses {
			obj2uses[obj] = append(obj2uses[obj], id)
		}
		for id, obj := range info.Defs {
			def2Objs[id] = append(def2Objs[id], obj)
		}
	})

	useMap := map[Def][]Use{}
	for def, objs := range def2Objs {
		for _, obj := range objs {
			for _, use := range obj2uses[obj] {
				useMap[def] = append(useMap[def], use)
			}
		}
	}
	return useMap
}

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Generator ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

// copy from go1.21 ast.IsGenerated

// IsGenerated reports whether the file was generated by a program,
// not handwritten, by detecting the special comment described
// at https://go.dev/s/generatedcode.
//
// The syntax tree must have been parsed with the ParseComments flag.
// Example:
//
//	f, err := parser.ParseFile(fset, filename, src, parser.ParseComments|parser.PackageClauseOnly)
//	if err != nil { ... }
//	gen := ast.IsGenerated(f)
func IsGenerated(file *ast.File) bool {
	_, ok := Generator(file)
	return ok
}

func Generator(file *ast.File) (by string, is bool) {
	var (
		cutPrefix = func(s, prefix string) (after string, found bool) {
			if !strings.HasPrefix(s, prefix) {
				return s, false
			}
			return s[len(prefix):], true
		}
		cutSuffix = func(s, suffix string) (before string, found bool) {
			if !strings.HasSuffix(s, suffix) {
				return s, false
			}
			return s[:len(s)-len(suffix)], true
		}
	)

	for _, group := range file.Comments {
		for _, comment := range group.List {
			if comment.Pos() > file.Package {
				break // after package declaration
			}
			// opt: check Contains first to avoid unnecessary array allocation in Split.
			const prefix = "// Code generated "
			if strings.Contains(comment.Text, prefix) {
				for _, line := range strings.Split(comment.Text, "\n") {
					if rest, ok := cutPrefix(line, prefix); ok {
						if gen, ok := cutSuffix(rest, " DO NOT EDIT."); ok {
							return gen, true
						}
					}
				}
			}
		}
	}
	return "", false
}
